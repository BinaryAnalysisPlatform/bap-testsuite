load_lib common.exp


proc arch-of-file {file} {
    lindex [split $file "-"] 0
}

proc abi-of-file {file} {
    lindex [split $file "-"] 2
}

proc tripple-of-file {file} {
    join [lrange [split $file "-"] 0 end-1] "-"
}


proc get-log {} {
    global logfile
    set fd [open $logfile]
    set data [read $fd]
    close $fd
    return $data
}

proc assert-non-zero {result file test} {
    if {$result == 0} {
        fail "$test in $file"
    } else {
        pass "$test in $file"
    }
}

proc assert-zero {result file test} {
    if {$result == 0} {
        pass "$test in $file"
    } else {
        fail "$test in $file"
    }
}


proc non-zero-matches {file pattern test} {
    set got [collect-matching $file $pattern]
    set matches [llength $got]
    assert-non-zero $matches $file $test
}

proc zero-matches {file pattern test} {
    set got [collect-matching $file $pattern]
    set matches [llength $got]
    assert-zero $matches $file $test
}

proc with-exit-code {name opts expected expected_status} {
    set status 0
    if {[catch {uplevel 0 exec bap $opts >& output.out} results options]} {
        set details [dict get $options -errorcode]
        if {[lindex $details 0] eq "CHILDSTATUS"} {
            set status [lindex $details 2]
        } else {
            # Some other error; regenerate it to let caller handle
            return -options $options -level 0 $results
        }
    }
    if {$status == $expected_status} {
        pass "got the expected exit status for the $name"
    } else {
        fail "got a wrong exit status for the $name"
    }
    non-zero-matches output "$expected.*" "got the right message for the $name"
    exec rm -f output.out
}


# `foreach-binary {file pattern} {expectations}` spawns bap with `-d`
# option on each binary in the test suite that matches with the
# `pattern`, and pass expectations to `expect`. The name passed as a
# `file` argument is bound to the filename.
proc foreach-binary {nampat command expectations} {
    foreach file [find "bin" [lindex $nampat 1]] {
        uplevel 1 set [lindex $nampat 0] $file
        uplevel 1 spawn $command "--" "$file"
        uplevel 1 expect [list $expectations]
    }
}

# `match file format opts expectations` matches
# the result of command `bap file opts` with the list
# of expectations. The `format` parameter specifies the
# format of output, e.g. bir, asm, symbols, ogre.
proc match { file {format ""} extra_opts expectations } {
    set opts [subst { "$file" "$extra_opts" } ]
    if { $format != "" } {
        lappend opts "--dump=$format"
    }
    set opts [join $opts " "]
    set level [expr [info level] - 1]
    match_output bap $opts $expectations $level
}

proc match_all {filename format extra_opts patterns {escaped false} } {
    global tool
    if { $format != "" } {
        lappend extra_opts "--dump=$format:$filename.out"
    }
    set opts [subst $extra_opts]
    set opts [join $opts " "]
    exec echo exec bap $filename $opts >> $tool.log
    catch {eval exec bap $filename $opts >& $filename.out}
    if { [file exists $filename.out] == 1 } {
        exec cat $filename.out >> $tool.log
    }

    set passed {}
    set failed {}
    foreach {pat test} $patterns {
        if { $escaped == true } {
            set pat [escape $pat]
        }
        set got [collect-matching $filename $pat]
        if { [llength $got] != 0} {
            lappend passed $test
        } else {
            lappend failed $test
        }
    }
    foreach p $passed { pass "$p" }
    foreach p $failed { fail "$p" }
    exec rm -f "$filename.out"
}

# `find_all file output strings name opts` ensures that all the
#strings can be found in the result of  `bap file opts` command.
# The `output` parameter defines what to match against the expectations,
# e.g. bir, asm, symbols, ogre
proc find_all {filename format strings test { extra_opts ""} } {
    set strs {}
    foreach str $strings {
        lappend strs $str
        lappend strs "$test for $str"
    }
    match_all $filename $format $extra_opts $strs true
}
